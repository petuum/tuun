import os
import shutil
import tempfile
import joblib
import tarfile
from urllib.request import urlopen
from pathlib import Path
import numpy as np

ENV_TUUN_CACHE = 'TUUN_CACHE'
ENV_XDG_CACHE_HOME = 'XDG_CACHE_HOME'
DEFAULT_CACHE_DIR = '~/.cache'


def get_tuun_cache_dir():
    """Return default cache directory."""
    cache_dir = os.path.expanduser(
        os.getenv(
            ENV_TUUN_CACHE,
            os.path.join(os.getenv(ENV_XDG_CACHE_HOME, DEFAULT_CACHE_DIR), 'tuun'),
        )
    )
    return cache_dir


def listdir_nohidden(path):
    """
    Returns list of non-hidden entries in path directory, similar to os.listdir.
    """
    entry_list = [entry for entry in os.listdir(path) if not entry.startswith('.')]
    return entry_list


class TransferRegression:
    def __init__(self, transfer_config, use_cached=True):
        """
        Generic regression model class for predicting the prior mean for a GP model

        Parameters
        ----------
        transfer_config : dict
            Config dictionary for tranfer regression model.
        use_cached : bool
            Flag to use cached models.
        """
        self.task_name = transfer_config['task_name']
        self.model_types = {'sklearn.linear_model.Ridge'}
        self.best_model = None
        self.model_type = transfer_config['model_type']
        self.output_mode = transfer_config.get('output_mode', 'val_accuracy')
        assert self.output_mode in ['val_accuracy', 'val_error']
        self.cache_dir = get_tuun_cache_dir()
        if not os.path.exists(self.cache_dir):
            os.makedirs(self.cache_dir)

        self.model_dir = os.path.join(self.cache_dir, self.task_name)
        if not os.path.exists(self.model_dir) or not use_cached:
            Path(self.model_dir).mkdir(parents=True, exist_ok=True)
            tmp_file = tempfile.NamedTemporaryFile()
            if 'remote_url' in transfer_config:
                # Download file to a temp dir to avoid overwriting
                # with corrupted file in case dowload fails
                with urlopen(transfer_config['remote_url']) as response:
                    shutil.copyfileobj(response, tmp_file, length=8192)
                filename = tmp_file.name
            else:
                filename = os.path.expanduser(transfer_config['local_path'])
            tarball = tarfile.open(filename)
            tarball.extractall(self.model_dir)
            tarball.close()
            tmp_file.close()

        # Get all non-hidden entries in self.model_dir
        self.model_fnames = listdir_nohidden(self.model_dir)

        # TODO: if extra files are in model_dir (e.g. accidentally/purposefully placed
        # by user, or automatically generated by OS), it breaks the following logic.
        if len(self.model_fnames) == 1:
            if not os.path.isfile(os.path.join(self.model_dir, self.model_fnames[0])):
                self.model_dir = os.path.join(self.model_dir, self.model_fnames[0])

                # Get all non-hidden entries in self.model_dir
                self.model_fnames = listdir_nohidden(self.model_dir)

    def get_model_prediction(self, model, X):
        """Return model prediction, based on self.model_type and config."""

        # Support custom regression models
        if 'sklearn' in self.model_type:

            # sklearn requires 2d numpy ndarray
            X = np.array(X)

            if len(X.shape) == 1:
                X = X.reshape(1, -1)

            # Make prediction
            prediction = model.predict(X)

        else:
            # Otherwise, assume model is callable
            prediction = model(X)

        # If val_error mode, return 1 - validation accuracy prediction
        if self.output_mode == 'val_error':
            prediction = 1 - prediction

        return prediction

    def evaluate_model(self, model_name, X):
        model_path = os.path.join(self.model_dir, model_name)
        model = self.load_model(model_path)
        prediction = self.get_model_prediction(model, X)
        return prediction

    def set_best_model(self, file_ind):
        if file_ind == -1:
            self.best_model = None
        else:
            model_name = self.model_fnames[file_ind]
            model_path = os.path.join(self.model_dir, model_name)
            self.best_model = self.load_model(model_path)

    def load_model(self, model_path):
        # TODO: Support custom regression models
        if 'sklearn' in self.model_type:
            model = joblib.load(model_path)
            return model
        else:
            raise NotImplementedError

    def __call__(self, X):
        if self.best_model is None:
            raise ValueError("Regression model not assigned")

        prediction = self.get_model_prediction(self.best_model, X)
        return prediction
